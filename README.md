# xatu-cbt-api

OpenAPI 3.0 specification generator for Xatu CBT REST API.

## Synopsis

This project generates a comprehensive OpenAPI specification from annotated Protocol Buffer definitions in [xatu-cbt](https://github.com/ethpandaops/xatu-cbt). The tool automatically flattens nested filter parameters into underscore notation and enriches them with field descriptions extracted from proto comments.

The result is a production-ready OpenAPI spec with REST endpoints covering all fact tables, complete with type-safe parameter validation and comprehensive documentation.

## Getting Started

### Quick Start

```bash
# Install required tools
make install-tools

# Generate the OpenAPI specification
make openapi

# Generate the Go server code
make generate-server

# Validate the generated spec
make validate

# View in Swagger UI
make serve-docs
```

The generated `openapi.yaml` and `internal/handlers/generated.go` will be available in the project.

## Make Commands

| Command | Description |
|---------|-------------|
| `make help` | Show all available commands |
| `make all` | Install tools, build, and generate OpenAPI spec and server code |
| `make openapi` | Generate OpenAPI specification from proto files |
| `make generate-server` | Generate Go server code from OpenAPI specification |
| `make build` | Build the openapi-filter-flatten tool |
| `make validate` | Validate the generated OpenAPI spec |
| `make serve-docs` | Serve OpenAPI spec with Swagger UI (http://localhost:3001) |
| `make install-tools` | Install required dependencies (protoc-gen-openapi, oapi-codegen, etc.) |
| `make clone-xatu-cbt` | Clone/update xatu-cbt repository for proto files |
| `make clean` | Remove all generated files and build artifacts |
| `make fmt` | Format Go code |
| `make lint` | Run Go linters |
| `make test` | Run tests |

## API Overview

### Endpoints

All fact tables (`fct_*`) from xatu-cbt are exposed as REST endpoints:

```
GET /api/v1/fct_attestation_correctness_by_validator_head
GET /api/v1/fct_block
GET /api/v1/fct_mev_bid_count_by_builder
... (54 total endpoints)
```

### Filter Parameters

Filters use underscore notation with operator suffixes:

```
?slot_start_date_time_gte=1609459200
?slot_start_date_time_lte=1609545600
?attesting_validator_index_eq=12345
?meta_client_name_in_values=lighthouse,prysm,teku
```

**Supported operators:**
- Scalar: `eq`, `ne`, `lt`, `lte`, `gt`, `gte`, `in_values`, `not_in_values`
- String: `contains`, `starts_with`, `ends_with`, `like`, `not_like`
- Nullable: `is_null`, `is_not_null`
- Map: `has_key`, `not_has_key`, `has_any_key`, `has_all_keys`

**Note:** List filters (`_in_values`, `_not_in_values`) use comma-separated strings for better HTTP client compatibility.

## Generated Server Code

The project uses `oapi-codegen` to generate Go server code from the OpenAPI specification.

### What Gets Generated

Running `make generate-server` creates `internal/handlers/generated.go` with:

1. **Request/Response Types** - All models from the OpenAPI spec
2. **Server Interface** - Interface to implement for each endpoint
3. **Parameter Structs** - Parsed and validated query parameters
4. **Router Setup** - Standard library HTTP server integration
5. **Embedded OpenAPI Spec** - OpenAPI spec embedded in the binary

### Server Interface

The generated code provides a `ServerInterface` that you need to implement:

```go
type ServerInterface interface {
    // List fct_block records
    // (GET /api/v1/fct_block)
    FctBlockServiceList(w http.ResponseWriter, r *http.Request, params FctBlockServiceListParams)

    // ... methods for all endpoints
}
```

### Parameter Parsing

All query parameters are automatically parsed and validated:

```go
type FctBlockServiceListParams struct {
    // Flattened filters with underscore notation
    SlotStartDateTimeEq    *int     `json:"slot_start_date_time_eq,omitempty"`
    SlotStartDateTimeGte   *int     `json:"slot_start_date_time_gte,omitempty"`
    SlotStartDateTimeLte   *int     `json:"slot_start_date_time_lte,omitempty"`

    // ... all filter parameters
}
```

### Using Proto-Generated Types

The implementation should convert between the HTTP layer types (generated by oapi-codegen) and the proto types:

```go
func (s *Server) FctBlockServiceList(w http.ResponseWriter, r *http.Request, params handlers.FctBlockServiceListParams) {
    // Convert HTTP params to proto request
    req := &clickhouse.ListFctBlockRequest{}

    if params.SlotStartDateTimeGte != nil && params.SlotStartDateTimeLte != nil {
        req.SlotStartDateTime = &clickhouse.UInt32Filter{
            Filter: &clickhouse.UInt32Filter_Between{
                Between: &clickhouse.UInt32Range{
                    Min: uint32(*params.SlotStartDateTimeGte),
                    Max: uint32(*params.SlotStartDateTimeLte),
                },
            },
        }
    }

    // Use existing Query Builder from xatu-cbt
    sqlQuery, _ := clickhouse.BuildListFctBlockQuery(req)

    // Execute and return response
    // ...
}
```

### Configuration

Server generation is configured via `oapi-codegen.yaml`:

```yaml
package: handlers
generate:
  models: true
  embedded-spec: true
  std-http-server: true
  strict-server: false
```

### Handler Registration

The generated code provides multiple ways to set up the HTTP server:

```go
// Option 1: Use default http.ServeMux
handler := handlers.Handler(serverImpl)
http.ListenAndServe(":8080", handler)

// Option 2: Use custom ServeMux
mux := http.NewServeMux()
handler := handlers.HandlerFromMux(serverImpl, mux)
http.ListenAndServe(":8080", handler)

// Option 3: Use with options (middleware, error handling)
handler := handlers.HandlerWithOptions(serverImpl, handlers.StdHTTPServerOptions{
    BaseURL:    "/api",
    BaseRouter: http.NewServeMux(),
    Middlewares: []handlers.MiddlewareFunc{loggingMiddleware, authMiddleware},
    ErrorHandlerFunc: customErrorHandler,
})
http.ListenAndServe(":8080", handler)
```

