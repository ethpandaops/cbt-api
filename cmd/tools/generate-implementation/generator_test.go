package main

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCodeGenerator_generateHeader(t *testing.T) {
	g := &CodeGenerator{}
	got := g.generateHeader()

	// Verify package declaration
	assert.Contains(t, got, "package server")

	// Verify required imports
	assert.Contains(t, got, "\"encoding/json\"")
	assert.Contains(t, got, "\"net/http\"")
	assert.Contains(t, got, "\"strconv\"")
	assert.Contains(t, got, "\"strings\"")
	assert.Contains(t, got, "github.com/ethpandaops/cbt-api/internal/config")
	assert.Contains(t, got, "github.com/ethpandaops/cbt-api/internal/database")
	assert.Contains(t, got, "github.com/ethpandaops/cbt-api/internal/handlers")
	assert.Contains(t, got, "github.com/ethpandaops/cbt-api/pkg/proto/clickhouse")
	assert.Contains(t, got, "google.golang.org/protobuf/types/known/emptypb")
	assert.Contains(t, got, "google.golang.org/protobuf/types/known/wrapperspb")

	// Verify code generation comment
	assert.Contains(t, got, "Code generated by generate-implementation. DO NOT EDIT.")
}

func TestCodeGenerator_generateServerStruct(t *testing.T) {
	g := &CodeGenerator{}
	got := g.generateServerStruct()

	assert.Contains(t, got, "type Server struct {")
	assert.Contains(t, got, "db     database.DatabaseClient")
	assert.Contains(t, got, "config *config.Config")
}

func TestCodeGenerator_generateHelpers(t *testing.T) {
	g := &CodeGenerator{}
	got := g.generateHelpers()

	// Check for all helper function signatures
	assert.Contains(t, got, "func parseUInt32List(s string) []uint32")
	assert.Contains(t, got, "func parseUInt64List(s string) []uint64")
	assert.Contains(t, got, "func parseInt32List(s string) []int32")
	assert.Contains(t, got, "func parseInt64List(s string) []int64")
	assert.Contains(t, got, "func parseStringList(s string) []string")

	// Verify they all use strings.Split
	assert.Equal(t, 5, strings.Count(got, "strings.Split"))

	// Verify they all use TrimSpace
	assert.Equal(t, 5, strings.Count(got, "strings.TrimSpace"))
}

func TestCodeGenerator_generateUtilities(t *testing.T) {
	g := &CodeGenerator{}
	got := g.generateUtilities()

	// Check for utility function signatures
	assert.Contains(t, got, "func writeJSON(w http.ResponseWriter, data any)")
	assert.Contains(t, got, "func writeError(w http.ResponseWriter, status int, err error)")
	assert.Contains(t, got, "func generateNextPageToken(currentToken string, itemCount int) string")
	assert.Contains(t, got, "func (s *Server) buildQueryOptions() []clickhouse.QueryOption")

	// Verify JSON encoding is used
	assert.Contains(t, got, "json.NewEncoder(w).Encode")

	// Verify content type is set
	assert.Contains(t, got, "application/json")

	// Verify query options include database and final
	assert.Contains(t, got, "clickhouse.WithDatabase(s.config.ClickHouse.Database)")
	assert.Contains(t, got, "clickhouse.WithFinal()")
}

func TestCodeGenerator_generateFieldMapping(t *testing.T) {
	tests := []struct {
		name      string
		fieldName string
		nullable  bool
		expected  []string
	}{
		{
			name:      "nullable field",
			fieldName: "Slot",
			nullable:  true,
			expected: []string{
				"if p.Slot != nil {",
				"val := p.Slot.GetValue()",
				"result.Slot = &val",
			},
		},
		{
			name:      "non-nullable field",
			fieldName: "BlockRoot",
			nullable:  false,
			expected: []string{
				"result.BlockRoot = &p.BlockRoot",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			g := &CodeGenerator{}
			got := g.generateFieldMapping(tt.fieldName, "string", tt.nullable)

			for _, expected := range tt.expected {
				assert.Contains(t, got, expected)
			}
		})
	}
}

func TestCodeGenerator_generateConverter(t *testing.T) {
	tests := []struct {
		name     string
		spec     *OpenAPISpec
		itemType string
		expected []string
	}{
		{
			name: "with schema",
			spec: &OpenAPISpec{
				Types: map[string]*Type{
					"FctBlock": {
						Fields: []Field{
							{Name: "slot", Nullable: false},
							{Name: "block_root", Nullable: true},
						},
					},
				},
			},
			itemType: "FctBlock",
			expected: []string{
				"func protoToOpenAPIFctBlock(p *clickhouse.FctBlock) handlers.FctBlock",
				"result := handlers.FctBlock{}",
				"result.Slot = &p.Slot",
				"if p.BlockRoot != nil {",
				"return result",
			},
		},
		{
			name:     "without schema",
			spec:     &OpenAPISpec{Types: map[string]*Type{}},
			itemType: "Unknown",
			expected: []string{
				"func protoToOpenAPIUnknown(p *clickhouse.Unknown) handlers.Unknown",
				"return handlers.Unknown{}",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			g := &CodeGenerator{spec: tt.spec}
			got := g.generateConverter(tt.itemType)

			for _, expected := range tt.expected {
				assert.Contains(t, got, expected)
			}
		})
	}
}

func TestCodeGenerator_generateTypeConverters(t *testing.T) {
	spec := &OpenAPISpec{
		Endpoints: []Endpoint{
			{TableName: "fct_block"},
			{TableName: "fct_attestation"},
			{TableName: "fct_block"}, // duplicate should be deduplicated
		},
		Types: map[string]*Type{
			"FctBlock": {
				Fields: []Field{
					{Name: "slot", Nullable: false},
				},
			},
			"FctAttestation": {
				Fields: []Field{
					{Name: "slot", Nullable: false},
				},
			},
		},
	}

	g := &CodeGenerator{spec: spec}
	got := g.generateTypeConverters()

	// Verify header comment
	assert.Contains(t, got, "// Type converters: Proto â†’ OpenAPI")

	// Verify both converters are present
	assert.Contains(t, got, "func protoToOpenAPIFctAttestation")
	assert.Contains(t, got, "func protoToOpenAPIFctBlock")

	// Verify sorted order (FctAttestation before FctBlock alphabetically)
	attestationIdx := strings.Index(got, "FctAttestation")
	blockIdx := strings.Index(got, "FctBlock")
	assert.Less(t, attestationIdx, blockIdx, "converters should be sorted alphabetically")
}

func TestCodeGenerator_Generate(t *testing.T) {
	spec := &OpenAPISpec{
		Endpoints: []Endpoint{
			{
				Path:         "/api/v1/fct_block",
				Method:       "GET",
				OperationID:  "FctBlockService_List",
				HandlerName:  "FctBlockServiceList",
				Operation:    "List",
				ParamsType:   "FctBlockServiceListParams",
				ResponseType: "ListFctBlockResponse",
				TableName:    "fct_block",
			},
		},
		Types: map[string]*Type{
			"FctBlock": {
				Fields: []Field{
					{Name: "slot", Nullable: false},
				},
			},
		},
	}

	protoInfo := &ProtoInfo{
		QueryBuilders: map[string]string{
			"fct_block:List": "BuildListFctBlockQuery",
		},
		RequestTypes: map[string]string{
			"fct_block:List": "ListFctBlockRequest",
		},
		RequestFields: map[string]map[string]string{
			"fct_block": {
				"slot": "UInt32Filter",
			},
		},
		FilterTypes: getKnownFilterTypes(),
	}

	g := &CodeGenerator{
		spec:      spec,
		protoInfo: protoInfo,
	}

	got := g.Generate()
	require.NotEmpty(t, got)

	// Verify all major sections are present
	assert.Contains(t, got, "package server")
	assert.Contains(t, got, "type Server struct {")
	assert.Contains(t, got, "func (s *Server) FctBlockServiceList")
	assert.Contains(t, got, "func writeJSON")
	assert.Contains(t, got, "func parseUInt32List")
	assert.Contains(t, got, "func buildUInt32Filter")

	// Verify proper ordering (header first, then struct, then endpoints)
	packageIdx := strings.Index(got, "package server")
	structIdx := strings.Index(got, "type Server struct")
	endpointIdx := strings.Index(got, "func (s *Server) FctBlockServiceList")
	utilitiesIdx := strings.Index(got, "func writeJSON")
	helpersIdx := strings.Index(got, "func parseUInt32List")
	filtersIdx := strings.Index(got, "func buildUInt32Filter")

	assert.Less(t, packageIdx, structIdx)
	assert.Less(t, structIdx, endpointIdx)
	assert.Less(t, endpointIdx, utilitiesIdx)
	assert.Less(t, utilitiesIdx, helpersIdx)
	assert.Less(t, helpersIdx, filtersIdx)
}
