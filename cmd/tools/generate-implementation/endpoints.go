package main

import (
	"fmt"
	"sort"
	"strings"
)

// generateEndpoints generates all endpoint implementations.
func generateEndpoints(spec *OpenAPISpec, protoInfo *ProtoInfo) string {
	var sb strings.Builder

	sb.WriteString("// Auto-generated endpoint implementations\n")
	sb.WriteString("// DO NOT EDIT - Generated by generate-implementation\n\n")

	for _, endpoint := range spec.Endpoints {
		switch endpoint.Operation {
		case "List":
			sb.WriteString(generateListEndpoint(endpoint, protoInfo))
			sb.WriteString("\n\n")
		case "Get":
			sb.WriteString(generateGetEndpoint(endpoint, protoInfo))
			sb.WriteString("\n\n")
		}
	}

	return sb.String()
}

// generateListEndpoint generates a List endpoint implementation.
func generateListEndpoint(ep Endpoint, protoInfo *ProtoInfo) string {
	// Use composite key to lookup proto info: "table:Operation"
	key := ep.TableName + ":" + ep.Operation
	queryBuilder := protoInfo.QueryBuilders[key]
	requestType := protoInfo.RequestTypes[key]
	itemType := getItemType(ep.TableName)
	itemFieldName := getItemFieldName(ep.TableName)

	// Skip if we don't have the query builder (shouldn't happen but be defensive)
	if queryBuilder == "" {
		return fmt.Sprintf("// Skipping %s - no query builder found for table %s:%s\n",
			ep.HandlerName, ep.TableName, ep.Operation)
	}

	return fmt.Sprintf(`// %s implements the %s endpoint
// %s %s
func (s *Server) %s(w http.ResponseWriter, r *http.Request, params handlers.%s) {
	ctx := r.Context()
	tracer := otel.Tracer("xatu-cbt-api/handlers")

	// Create span for handler execution
	ctx, span := tracer.Start(ctx, "handler.%s",
		trace.WithAttributes(
			attribute.String("handler.name", "%s"),
			attribute.String("handler.operation", "List"),
		),
	)
	defer span.End()

	// Build proto request
	req := &clickhouse.%s{
		PageSize: 100, // default
	}

%s
	// Pagination
	if params.PageSize != nil {
		req.PageSize = *params.PageSize
		span.SetAttributes(attribute.Int("pagination.page_size", int(*params.PageSize)))
	}
	if params.PageToken != nil {
		req.PageToken = *params.PageToken
		span.SetAttributes(attribute.String("pagination.page_token", *params.PageToken))
	}

	// Use existing Query Builder
	_, buildSpan := tracer.Start(ctx, "handler.buildQuery")
	sqlQuery, err := clickhouse.%s(req, s.buildQueryOptions()...)
	buildSpan.End()
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "failed to build query")
		writeError(w, http.StatusBadRequest, err)
		return
	}

	// Execute query (database wrapper creates child span)
	rows, err := s.db.Query(ctx, sqlQuery.Query, sqlQuery.Args...)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "query failed")
		writeError(w, http.StatusInternalServerError, err)
		return
	}
	defer rows.Close()

	// Scan results directly into OpenAPI types
	_, scanSpan := tracer.Start(ctx, "handler.scanResults")
	var items []handlers.%s
	for rows.Next() {
		var item handlers.%s
		if err := rows.ScanStruct(&item); err != nil {
			scanSpan.RecordError(err)
			scanSpan.End()
			span.RecordError(err)
			span.SetStatus(codes.Error, "scan failed")
			writeError(w, http.StatusInternalServerError, err)
			return
		}
		items = append(items, item)
	}
	scanSpan.SetAttributes(attribute.Int("result.count", len(items)))
	scanSpan.End()

	// Build response
	response := handlers.%s{
		%s: items,
	}

	// Add pagination token
	if len(items) == int(req.PageSize) {
		nextToken := generateNextPageToken(req.PageToken, len(items))
		response.NextPageToken = &nextToken
	}

	span.SetAttributes(attribute.Int("response.item_count", len(items)))
	span.SetStatus(codes.Ok, "")
	writeJSON(w, response)
}`,
		ep.HandlerName, ep.OperationID, ep.Method, ep.Path,
		ep.HandlerName, ep.ParamsType,
		ep.HandlerName, ep.HandlerName,
		requestType,
		generateFilterAssignments(ep, protoInfo),
		queryBuilder,
		itemType,
		itemType,
		ep.ResponseType,
		itemFieldName)
}

// generateGetEndpoint generates a Get endpoint implementation with path parameter.
func generateGetEndpoint(ep Endpoint, protoInfo *ProtoInfo) string {
	// Use composite key to lookup proto info: "table:Operation"
	key := ep.TableName + ":" + ep.Operation
	queryBuilder := protoInfo.QueryBuilders[key]
	requestType := protoInfo.RequestTypes[key]
	itemType := getItemType(ep.TableName)

	// Skip if we don't have the query builder
	if queryBuilder == "" {
		return fmt.Sprintf("// Skipping %s - no query builder found for table %s:%s\n",
			ep.HandlerName, ep.TableName, ep.Operation)
	}

	// Get path parameter info
	if ep.PathParameter == nil {
		return fmt.Sprintf("// Skipping %s - no path parameter defined\n", ep.HandlerName)
	}

	pathParam := ep.PathParameter
	pathParamName := pathParam.Name
	pathParamType := strings.TrimPrefix(pathParam.GoType, "*") // Remove pointer for path params

	return fmt.Sprintf(`// %s implements the %s endpoint
// %s %s
func (s *Server) %s(w http.ResponseWriter, r *http.Request, %s %s) {
	ctx := r.Context()
	tracer := otel.Tracer("xatu-cbt-api/handlers")

	// Create span for handler execution
	ctx, span := tracer.Start(ctx, "handler.%s",
		trace.WithAttributes(
			attribute.String("handler.name", "%s"),
			attribute.String("handler.operation", "Get"),
			attribute.String("path.parameter", "%s"),
		),
	)
	defer span.End()

	// Build proto request
	req := &clickhouse.%s{
		%s: %s,
	}

	// Use existing Query Builder
	_, buildSpan := tracer.Start(ctx, "handler.buildQuery")
	sqlQuery, err := clickhouse.%s(req, s.buildQueryOptions()...)
	buildSpan.End()
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "failed to build query")
		writeError(w, http.StatusBadRequest, err)
		return
	}

	// Execute query (database wrapper creates child span)
	rows, err := s.db.Query(ctx, sqlQuery.Query, sqlQuery.Args...)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "query failed")
		writeError(w, http.StatusInternalServerError, err)
		return
	}
	defer rows.Close()

	// Scan single result directly into OpenAPI type
	_, scanSpan := tracer.Start(ctx, "handler.scanResults")
	var item handlers.%s
	if rows.Next() {
		if err := rows.ScanStruct(&item); err != nil {
			scanSpan.RecordError(err)
			scanSpan.End()
			span.RecordError(err)
			span.SetStatus(codes.Error, "scan failed")
			writeError(w, http.StatusInternalServerError, err)
			return
		}
	} else {
		scanSpan.SetAttributes(attribute.Bool("result.found", false))
		scanSpan.End()
		span.SetStatus(codes.Ok, "not found")
		// Not found
		w.WriteHeader(http.StatusNotFound)
		return
	}
	scanSpan.SetAttributes(attribute.Bool("result.found", true))
	scanSpan.End()

	span.SetStatus(codes.Ok, "")
	writeJSON(w, item)
}`,
		ep.HandlerName, ep.OperationID, ep.Method, ep.Path,
		ep.HandlerName, pathParamName, pathParamType,
		ep.HandlerName, ep.HandlerName, pathParamName,
		requestType,
		toPascalCase(pathParamName), pathParamName,
		queryBuilder,
		itemType)
}

// generateFilterAssignments generates filter field assignments from HTTP params to proto request.
func generateFilterAssignments(ep Endpoint, protoInfo *ProtoInfo) string {
	var sb strings.Builder

	// Get the request fields for this table
	requestFields, ok := protoInfo.RequestFields[ep.TableName]
	if !ok {
		// No field mappings available for this table
		return ""
	}

	// Group parameters by field
	fieldParams := make(map[string][]Param)

	for _, param := range ep.Parameters {
		if param.Operator != "" {
			fieldParams[param.Field] = append(fieldParams[param.Field], param)
		}
	}

	// Sort fields for deterministic output
	fields := make([]string, 0, len(fieldParams))
	for field := range fieldParams {
		fields = append(fields, field)
	}

	sort.Strings(fields)

	// Generate filter assignment for each field that exists in proto
	for _, field := range fields {
		params := fieldParams[field]

		// Check if this field exists in the proto request
		filterType, exists := requestFields[field]
		if !exists {
			// Skip fields that don't exist in the proto request
			continue
		}

		builderFunc := "build" + filterType
		builderArgs := generateBuilderArgs(params, filterType)

		sb.WriteString(fmt.Sprintf("\t// Filter: %s (%s)\n", field, filterType))
		sb.WriteString(fmt.Sprintf("\treq.%s = %s(%s)\n",
			toPascalCase(field),
			builderFunc,
			builderArgs,
		))
	}

	return sb.String()
}

// generateBuilderArgs generates the arguments for a filter builder function in the correct order.
func generateBuilderArgs(params []Param, filterType string) string {
	// Map operator → parameter
	argMap := make(map[string]string)
	for _, p := range params {
		argMap[p.Operator] = "params." + toPascalCase(p.Name)
	}

	// Generate args in expected order based on filter type
	var args []string

	if strings.HasPrefix(filterType, "Map") {
		// Map filters: hasKey, notHasKey, hasAnyKey, hasAllKeys
		for _, op := range []string{"has_key", "not_has_key", "has_any_key", "has_all_keys"} {
			if arg, ok := argMap[op]; ok {
				args = append(args, arg)
			} else {
				args = append(args, "nil")
			}
		}
	} else if strings.Contains(filterType, "String") {
		// String filters
		baseOps := []string{"eq", "ne", "contains", "starts_with", "ends_with", "like", "not_like", "in", "not_in"}
		for _, op := range baseOps {
			if arg, ok := argMap[op]; ok {
				args = append(args, arg)
			} else {
				args = append(args, "nil")
			}
		}
		// Add is_null/is_not_null if nullable
		if strings.HasPrefix(filterType, "Nullable") {
			for _, op := range []string{"is_null", "is_not_null"} {
				if arg, ok := argMap[op]; ok {
					args = append(args, arg)
				} else {
					args = append(args, "nil")
				}
			}
		}
	} else if strings.Contains(filterType, "Bool") {
		// Bool filters: eq, ne
		for _, op := range []string{"eq", "ne"} {
			if arg, ok := argMap[op]; ok {
				args = append(args, arg)
			} else {
				args = append(args, "nil")
			}
		}
		// Add is_null/is_not_null if nullable
		if strings.HasPrefix(filterType, "Nullable") {
			for _, op := range []string{"is_null", "is_not_null"} {
				if arg, ok := argMap[op]; ok {
					args = append(args, arg)
				} else {
					args = append(args, "nil")
				}
			}
		}
	} else {
		// Numeric filters: eq, ne, lt, lte, gt, gte, in_values, not_in_values
		for _, op := range []string{"eq", "ne", "lt", "lte", "gt", "gte", "in_values", "not_in_values"} {
			if arg, ok := argMap[op]; ok {
				args = append(args, arg)
			} else {
				args = append(args, "nil")
			}
		}
		// Add is_null/is_not_null if nullable
		if strings.HasPrefix(filterType, "Nullable") {
			for _, op := range []string{"is_null", "is_not_null"} {
				if arg, ok := argMap[op]; ok {
					args = append(args, arg)
				} else {
					args = append(args, "nil")
				}
			}
		}
	}

	return strings.Join(args, ", ")
}

// getItemType converts a table name to its item type name.
func getItemType(tableName string) string {
	// "fct_block" → "FctBlock"
	// "fct_node_active_last_24_h" → "FctNodeActiveLast24H" (matching protoc capitalization)
	pascalName := toPascalCase(tableName)

	return normalizeProtoTypeName(pascalName)
}

// getItemFieldName converts a table name to the field name used in response structs by oapi-codegen.
func getItemFieldName(tableName string) string {
	// Field names in oapi-codegen use simple PascalCase without special numeric suffix handling
	// "fct_node_active_last_24h" → "FctNodeActiveLast24h" (not "FctNodeActiveLast24H")
	// "fct_attestation_first_seen_chunked_50ms" → "FctAttestationFirstSeenChunked50ms" (not "FctAttestationFirstSeenChunked50Ms")
	parts := strings.Split(tableName, "_")
	for i := range parts {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}

	return strings.Join(parts, "")
}
