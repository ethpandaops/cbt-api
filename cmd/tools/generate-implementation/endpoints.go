package main

import (
	"fmt"
	"sort"
	"strings"
)

func generateEndpoints(spec *OpenAPISpec, protoInfo *ProtoInfo) string {
	var sb strings.Builder

	sb.WriteString("// Auto-generated endpoint implementations\n")
	sb.WriteString("// DO NOT EDIT - Generated by generate-implementation\n\n")

	for _, endpoint := range spec.Endpoints {
		switch endpoint.Operation {
		case "List":
			sb.WriteString(generateEndpoint(endpoint, protoInfo))
			sb.WriteString("\n\n")
		case "Get":
			sb.WriteString(generateGetEndpoint(endpoint, protoInfo))
			sb.WriteString("\n\n")
		}
	}

	return sb.String()
}

func generateEndpoint(ep Endpoint, protoInfo *ProtoInfo) string {
	// Use composite key to lookup proto info: "table:Operation"
	key := ep.TableName + ":" + ep.Operation
	queryBuilder := protoInfo.QueryBuilders[key]
	requestType := protoInfo.RequestTypes[key]
	itemType := getItemType(ep.TableName)
	itemFieldName := getItemFieldName(ep.TableName)

	// Skip if we don't have the query builder (shouldn't happen but be defensive)
	if queryBuilder == "" {
		return fmt.Sprintf("// Skipping %s - no query builder found for table %s:%s\n",
			ep.HandlerName, ep.TableName, ep.Operation)
	}

	return fmt.Sprintf(`// %s implements the %s endpoint
// %s %s
func (s *Server) %s(w http.ResponseWriter, r *http.Request, params handlers.%s) {
	ctx := r.Context()

	// Build proto request
	req := &clickhouse.%s{
		PageSize: 100, // default
	}

%s
	// Pagination
	if params.PageSize != nil {
		req.PageSize = *params.PageSize
	}
	if params.PageToken != nil {
		req.PageToken = *params.PageToken
	}

	// Use existing Query Builder
	sqlQuery, err := clickhouse.%s(req,
		clickhouse.WithDatabase(s.config.ClickHouse.Database),
		clickhouse.WithFinal(s.config.ClickHouse.UseFinal),
	)
	if err != nil {
		writeError(w, http.StatusBadRequest, err)
		return
	}

	// Execute query
	rows, err := s.db.Query(ctx, sqlQuery.Query, sqlQuery.Args...)
	if err != nil {
		writeError(w, http.StatusInternalServerError, err)
		return
	}
	defer rows.Close()

	// Scan results
	var items []handlers.%s
	for rows.Next() {
		var item clickhouse.%s
		if err := rows.ScanStruct(&item); err != nil {
			writeError(w, http.StatusInternalServerError, err)
			return
		}
		items = append(items, protoToOpenAPI%s(&item))
	}

	// Build response
	response := handlers.%s{
		%s: &items,
	}

	// Add pagination token
	if len(items) == int(req.PageSize) {
		nextToken := generateNextPageToken(req.PageToken, len(items))
		response.NextPageToken = &nextToken
	}

	writeJSON(w, response)
}`,
		ep.HandlerName, ep.OperationID, ep.Method, ep.Path,
		ep.HandlerName, ep.ParamsType,
		requestType,
		generateFilterAssignments(ep, protoInfo),
		queryBuilder,
		itemType,
		itemType,
		itemType,
		ep.ResponseType,
		itemFieldName)
}

func generateGetEndpoint(ep Endpoint, protoInfo *ProtoInfo) string {
	// Use composite key to lookup proto info: "table:Operation"
	key := ep.TableName + ":" + ep.Operation
	queryBuilder := protoInfo.QueryBuilders[key]
	requestType := protoInfo.RequestTypes[key]
	itemType := getItemType(ep.TableName)

	// Skip if we don't have the query builder
	if queryBuilder == "" {
		return fmt.Sprintf("// Skipping %s - no query builder found for table %s:%s\n",
			ep.HandlerName, ep.TableName, ep.Operation)
	}

	// Get path parameter info
	if ep.PathParameter == nil {
		return fmt.Sprintf("// Skipping %s - no path parameter defined\n", ep.HandlerName)
	}

	pathParam := ep.PathParameter
	pathParamName := pathParam.Name
	pathParamType := strings.TrimPrefix(pathParam.GoType, "*") // Remove pointer for path params

	return fmt.Sprintf(`// %s implements the %s endpoint
// %s %s
func (s *Server) %s(w http.ResponseWriter, r *http.Request, %s %s) {
	ctx := r.Context()

	// Build proto request
	req := &clickhouse.%s{
		%s: %s,
	}

	// Use existing Query Builder
	sqlQuery, err := clickhouse.%s(req,
		clickhouse.WithDatabase(s.config.ClickHouse.Database),
		clickhouse.WithFinal(s.config.ClickHouse.UseFinal),
	)
	if err != nil {
		writeError(w, http.StatusBadRequest, err)
		return
	}

	// Execute query
	rows, err := s.db.Query(ctx, sqlQuery.Query, sqlQuery.Args...)
	if err != nil {
		writeError(w, http.StatusInternalServerError, err)
		return
	}
	defer rows.Close()

	// Scan single result
	var item clickhouse.%s
	if rows.Next() {
		if err := rows.ScanStruct(&item); err != nil {
			writeError(w, http.StatusInternalServerError, err)
			return
		}
	} else {
		// Not found
		w.WriteHeader(http.StatusNotFound)
		return
	}

	// Build response
	response := protoToOpenAPI%s(&item)
	writeJSON(w, response)
}`,
		ep.HandlerName, ep.OperationID, ep.Method, ep.Path,
		ep.HandlerName, pathParamName, pathParamType,
		requestType,
		toPascalCase(pathParamName), pathParamName,
		queryBuilder,
		itemType,
		itemType)
}

func generateFilterAssignments(ep Endpoint, protoInfo *ProtoInfo) string {
	var sb strings.Builder

	// Get the request fields for this table
	requestFields, ok := protoInfo.RequestFields[ep.TableName]
	if !ok {
		// No field mappings available for this table
		return ""
	}

	// Group parameters by field
	fieldParams := make(map[string][]Param)

	for _, param := range ep.Parameters {
		if param.Operator != "" {
			fieldParams[param.Field] = append(fieldParams[param.Field], param)
		}
	}

	// Sort fields for deterministic output
	fields := make([]string, 0, len(fieldParams))
	for field := range fieldParams {
		fields = append(fields, field)
	}

	sort.Strings(fields)

	// Generate filter assignment for each field that exists in proto
	for _, field := range fields {
		params := fieldParams[field]

		// Check if this field exists in the proto request
		filterType, exists := requestFields[field]
		if !exists {
			// Skip fields that don't exist in the proto request
			continue
		}

		builderFunc := "build" + filterType
		builderArgs := generateBuilderArgs(params, filterType)

		sb.WriteString(fmt.Sprintf("\t// Filter: %s (%s)\n", field, filterType))
		sb.WriteString(fmt.Sprintf("\treq.%s = %s(%s)\n",
			toPascalCase(field),
			builderFunc,
			builderArgs,
		))
	}

	return sb.String()
}

func generateBuilderArgs(params []Param, filterType string) string {
	// Map operator → parameter
	argMap := make(map[string]string)
	for _, p := range params {
		argMap[p.Operator] = "params." + toPascalCase(p.Name)
	}

	// Generate args in expected order based on filter type
	var args []string

	if strings.HasPrefix(filterType, "Map") {
		// Map filters: hasKey, notHasKey, hasAnyKey, hasAllKeys
		for _, op := range []string{"has_key", "not_has_key", "has_any_key", "has_all_keys"} {
			if arg, ok := argMap[op]; ok {
				args = append(args, arg)
			} else {
				args = append(args, "nil")
			}
		}
	} else if strings.Contains(filterType, "String") {
		// String filters
		baseOps := []string{"eq", "ne", "contains", "starts_with", "ends_with", "like", "not_like", "in", "not_in"}
		for _, op := range baseOps {
			if arg, ok := argMap[op]; ok {
				args = append(args, arg)
			} else {
				args = append(args, "nil")
			}
		}
		// Add is_null/is_not_null if nullable
		if strings.HasPrefix(filterType, "Nullable") {
			for _, op := range []string{"is_null", "is_not_null"} {
				if arg, ok := argMap[op]; ok {
					args = append(args, arg)
				} else {
					args = append(args, "nil")
				}
			}
		}
	} else if strings.Contains(filterType, "Bool") {
		// Bool filters: eq, ne
		for _, op := range []string{"eq", "ne"} {
			if arg, ok := argMap[op]; ok {
				args = append(args, arg)
			} else {
				args = append(args, "nil")
			}
		}
		// Add is_null/is_not_null if nullable
		if strings.HasPrefix(filterType, "Nullable") {
			for _, op := range []string{"is_null", "is_not_null"} {
				if arg, ok := argMap[op]; ok {
					args = append(args, arg)
				} else {
					args = append(args, "nil")
				}
			}
		}
	} else {
		// Numeric filters: eq, ne, lt, lte, gt, gte, in, not_in
		for _, op := range []string{"eq", "ne", "lt", "lte", "gt", "gte", "in", "not_in"} {
			if arg, ok := argMap[op]; ok {
				args = append(args, arg)
			} else {
				args = append(args, "nil")
			}
		}
		// Add is_null/is_not_null if nullable
		if strings.HasPrefix(filterType, "Nullable") {
			for _, op := range []string{"is_null", "is_not_null"} {
				if arg, ok := argMap[op]; ok {
					args = append(args, arg)
				} else {
					args = append(args, "nil")
				}
			}
		}
	}

	return strings.Join(args, ", ")
}

func getItemType(tableName string) string {
	// "fct_block" → "FctBlock"
	return toPascalCase(tableName)
}

func getItemFieldName(tableName string) string {
	// Field names in oapi-codegen use simple PascalCase without special numeric suffix handling
	// "fct_node_active_last_24h" → "FctNodeActiveLast24h" (not "FctNodeActiveLast24H")
	// "fct_attestation_first_seen_chunked_50ms" → "FctAttestationFirstSeenChunked50ms" (not "FctAttestationFirstSeenChunked50Ms")
	parts := strings.Split(tableName, "_")
	for i := range parts {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}

	return strings.Join(parts, "")
}
