package main

import (
	"fmt"
	"sort"
	"strings"
)

// generateFilterBuilders generates filter builder functions for all filter types.
func generateFilterBuilders(protoInfo *ProtoInfo) string {
	var sb strings.Builder

	sb.WriteString("// Auto-generated filter builder functions\n")
	sb.WriteString("// DO NOT EDIT - Generated by generate-implementation\n\n")

	// Sort filter types for deterministic output
	filterNames := make([]string, 0, len(protoInfo.FilterTypes))
	for name := range protoInfo.FilterTypes {
		filterNames = append(filterNames, name)
	}

	sort.Strings(filterNames)

	// Generate builder for each filter type
	for _, name := range filterNames {
		filterType := protoInfo.FilterTypes[name]

		if filterType.IsMap {
			sb.WriteString(generateMapFilterBuilder(filterType))
		} else if filterType.IsNullable {
			sb.WriteString(generateNullableFilterBuilder(filterType))
		} else {
			sb.WriteString(generateScalarFilterBuilder(filterType))
		}

		sb.WriteString("\n")
	}

	return sb.String()
}

// generateScalarFilterBuilder generates a filter builder for scalar (non-nullable) filter types.
func generateScalarFilterBuilder(ft *FilterType) string {
	funcName := "build" + ft.Name
	params := generateFilterParams(ft)
	nilCheck := generateNilCheck(ft)
	baseTypePascal := toProtoTypeName(ft.BaseType)

	// Bool types only support eq/ne, not ranges or lists
	if ft.BaseType == "bool" {
		return fmt.Sprintf(`// %s builds a %s from flattened parameters.
func %s(%s) *clickhouse.%s {
	// Return nil if no filters provided
	if %s {
		return nil
	}

	// Priority 1: Equality
	if eq != nil {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_Eq{Eq: *eq},
		}
	}

	// Priority 2: Not equal
	if ne != nil {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_Ne{Ne: *ne},
		}
	}

	return nil
}

`, ft.Name, ft.Name, funcName, params, ft.Name, nilCheck,
			ft.Name, ft.Name,
			ft.Name, ft.Name)
	}

	// String types support eq/ne/contains/starts_with/ends_with/like/not_like/in/not_in
	if ft.BaseType == "string" {
		return fmt.Sprintf(`// %s builds a %s from flattened parameters.
// Priority: eq > string ops (contains/starts_with/ends_with/like) > in > not_in
func %s(%s) *clickhouse.%s {
	// Return nil if no filters provided
	if %s {
		return nil
	}

	// Priority 1: Equality
	if eq != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Eq{Eq: *eq}}
	}

	// Priority 2: String-specific operators
	if contains != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Contains{Contains: *contains}}
	}
	if startsWith != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_StartsWith{StartsWith: *startsWith}}
	}
	if endsWith != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_EndsWith{EndsWith: *endsWith}}
	}
	if like != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Like{Like: *like}}
	}
	if notLike != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_NotLike{NotLike: *notLike}}
	}
	if ne != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Ne{Ne: *ne}}
	}

	// Priority 3: IN list
	if in != nil {
		values := parseStringList(*in)
		return &clickhouse.%s{
			Filter: &clickhouse.%s_In{In: &clickhouse.StringList{Values: values}},
		}
	}

	// Priority 4: NOT IN list
	if notIn != nil {
		values := parseStringList(*notIn)
		return &clickhouse.%s{
			Filter: &clickhouse.%s_NotIn{NotIn: &clickhouse.StringList{Values: values}},
		}
	}

	return nil
}

`, ft.Name, ft.Name, funcName, params, ft.Name, nilCheck,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name)
	}

	// Numeric types support full range of operations
	return fmt.Sprintf(`// %s builds a %s from flattened parameters.
// Priority: eq > between (gte+lte) > individual ops > in > not_in
func %s(%s) *clickhouse.%s {
	// Return nil if no filters provided
	if %s {
		return nil
	}

	// Priority 1: Equality
	if eq != nil {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_Eq{Eq: *eq},
		}
	}

	// Priority 2: Auto-combine gte + lte into BETWEEN for optimization
	if gte != nil && lte != nil {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_Between{
				Between: &clickhouse.%sRange{
					Min: *gte,
					Max: &wrapperspb.%sValue{Value: *lte},
				},
			},
		}
	}

	// Priority 3: Individual range operators
	if lte != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Lte{Lte: *lte}}
	}
	if gte != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Gte{Gte: *gte}}
	}
	if lt != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Lt{Lt: *lt}}
	}
	if gt != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Gt{Gt: *gt}}
	}
	if ne != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Ne{Ne: *ne}}
	}

	// Priority 4: IN list
	if in != nil {
		values := parse%sList(*in)
		return &clickhouse.%s{
			Filter: &clickhouse.%s_In{
				In: &clickhouse.%sList{Values: values},
			},
		}
	}

	// Priority 5: NOT IN list
	if notIn != nil {
		values := parse%sList(*notIn)
		return &clickhouse.%s{
			Filter: &clickhouse.%s_NotIn{
				NotIn: &clickhouse.%sList{Values: values},
			},
		}
	}

	return nil
}

`, ft.Name, ft.Name, funcName, params, ft.Name, nilCheck,
		ft.Name, ft.Name,
		ft.Name, ft.Name, baseTypePascal, baseTypePascal,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		baseTypePascal, ft.Name, ft.Name, baseTypePascal,
		baseTypePascal, ft.Name, ft.Name, baseTypePascal)
}

// generateNullableFilterBuilder generates a filter builder for nullable filter types.
func generateNullableFilterBuilder(ft *FilterType) string {
	funcName := "build" + ft.Name
	params := generateFilterParams(ft)
	baseTypePascal := toProtoTypeName(ft.BaseType)

	// Bool types only support eq/ne/is_null/is_not_null
	if ft.BaseType == "bool" {
		return fmt.Sprintf(`// %s builds a %s from flattened parameters.
func %s(%s) *clickhouse.%s {
	// Check for null operators first
	if isNull != nil && *isNull {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_IsNull{IsNull: &emptypb.Empty{}},
		}
	}
	if isNotNull != nil && *isNotNull {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_IsNotNull{IsNotNull: &emptypb.Empty{}},
		}
	}

	// Equality
	if eq != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Eq{Eq: *eq}}
	}

	// Not equal
	if ne != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Ne{Ne: *ne}}
	}

	return nil
}

`, ft.Name, ft.Name, funcName, params, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name)
	}

	// String types support eq/ne/contains/starts_with/ends_with/like/not_like/in/not_in/is_null/is_not_null
	if ft.BaseType == "string" {
		return fmt.Sprintf(`// %s builds a %s from flattened parameters.
func %s(%s) *clickhouse.%s {
	// Check for null operators first
	if isNull != nil && *isNull {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_IsNull{IsNull: &emptypb.Empty{}},
		}
	}
	if isNotNull != nil && *isNotNull {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_IsNotNull{IsNotNull: &emptypb.Empty{}},
		}
	}

	// Priority 1: Equality
	if eq != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Eq{Eq: *eq}}
	}

	// Priority 2: String-specific operators
	if contains != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Contains{Contains: *contains}}
	}
	if startsWith != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_StartsWith{StartsWith: *startsWith}}
	}
	if endsWith != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_EndsWith{EndsWith: *endsWith}}
	}
	if like != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Like{Like: *like}}
	}
	if notLike != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_NotLike{NotLike: *notLike}}
	}
	if ne != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Ne{Ne: *ne}}
	}

	// Priority 3: IN list
	if in != nil {
		values := parseStringList(*in)
		return &clickhouse.%s{
			Filter: &clickhouse.%s_In{In: &clickhouse.StringList{Values: values}},
		}
	}

	// Priority 4: NOT IN list
	if notIn != nil {
		values := parseStringList(*notIn)
		return &clickhouse.%s{
			Filter: &clickhouse.%s_NotIn{NotIn: &clickhouse.StringList{Values: values}},
		}
	}

	return nil
}

`, ft.Name, ft.Name, funcName, params, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name,
			ft.Name, ft.Name)
	}

	// Numeric types support full range of operations
	return fmt.Sprintf(`// %s builds a %s from flattened parameters.
func %s(%s) *clickhouse.%s {
	// Check for null operators first
	if isNull != nil && *isNull {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_IsNull{IsNull: &emptypb.Empty{}},
		}
	}
	if isNotNull != nil && *isNotNull {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_IsNotNull{IsNotNull: &emptypb.Empty{}},
		}
	}

	// Same logic as non-nullable version
	if eq != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Eq{Eq: *eq}}
	}

	if gte != nil && lte != nil {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_Between{
				Between: &clickhouse.%sRange{Min: *gte, Max: &wrapperspb.%sValue{Value: *lte}},
			},
		}
	}

	if lte != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Lte{Lte: *lte}}
	}
	if gte != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Gte{Gte: *gte}}
	}
	if lt != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Lt{Lt: *lt}}
	}
	if gt != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Gt{Gt: *gt}}
	}
	if ne != nil {
		return &clickhouse.%s{Filter: &clickhouse.%s_Ne{Ne: *ne}}
	}

	if in != nil {
		values := parse%sList(*in)
		return &clickhouse.%s{
			Filter: &clickhouse.%s_In{In: &clickhouse.%sList{Values: values}},
		}
	}

	if notIn != nil {
		values := parse%sList(*notIn)
		return &clickhouse.%s{
			Filter: &clickhouse.%s_NotIn{NotIn: &clickhouse.%sList{Values: values}},
		}
	}

	return nil
}

`, ft.Name, ft.Name, funcName, params, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name, baseTypePascal, baseTypePascal,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		baseTypePascal, ft.Name, ft.Name, baseTypePascal,
		baseTypePascal, ft.Name, ft.Name, baseTypePascal)
}

// generateMapFilterBuilder generates a filter builder for map filter types.
func generateMapFilterBuilder(ft *FilterType) string {
	funcName := "build" + ft.Name

	return fmt.Sprintf(`// %s builds a %s from flattened parameters.
func %s(hasKey, notHasKey, hasAnyKey, hasAllKeys *string) *clickhouse.%s {
	if hasKey == nil && notHasKey == nil && hasAnyKey == nil && hasAllKeys == nil {
		return nil
	}

	// Priority: has_key > not_has_key > has_any_key > has_all_keys
	if hasKey != nil {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_HasKey{HasKey: *hasKey},
		}
	}

	if notHasKey != nil {
		return &clickhouse.%s{
			Filter: &clickhouse.%s_NotHasKey{NotHasKey: *notHasKey},
		}
	}

	if hasAnyKey != nil {
		keys := strings.Split(*hasAnyKey, ",")
		for i := range keys {
			keys[i] = strings.TrimSpace(keys[i])
		}
		return &clickhouse.%s{
			Filter: &clickhouse.%s_HasAnyKey{
				HasAnyKey: &clickhouse.StringList{Values: keys},
			},
		}
	}

	if hasAllKeys != nil {
		keys := strings.Split(*hasAllKeys, ",")
		for i := range keys {
			keys[i] = strings.TrimSpace(keys[i])
		}
		return &clickhouse.%s{
			Filter: &clickhouse.%s_HasAllKeys{
				HasAllKeys: &clickhouse.StringList{Values: keys},
			},
		}
	}

	return nil
}

`, ft.Name, ft.Name, funcName, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name,
		ft.Name, ft.Name)
}

// generateFilterParams generates the function parameter list for a filter builder.
func generateFilterParams(ft *FilterType) string {
	goType := "*" + ft.BaseType

	if ft.IsNullable {
		if ft.BaseType == "string" {
			return "eq, ne, contains, startsWith, endsWith, like, notLike *string, in, notIn *string, isNull, isNotNull *bool"
		}

		if ft.BaseType == "bool" {
			return "eq, ne *bool, isNull, isNotNull *bool"
		}

		return fmt.Sprintf("eq, ne, lt, lte, gt, gte %s, in, notIn *string, isNull, isNotNull *bool", goType)
	}

	if ft.BaseType == "string" {
		return "eq, ne, contains, startsWith, endsWith, like, notLike *string, in, notIn *string"
	}

	if ft.BaseType == "bool" {
		return "eq, ne *bool"
	}

	// Numeric types
	return fmt.Sprintf("eq, ne, lt, lte, gt, gte %s, in, notIn *string", goType)
}

// generateNilCheck generates a nil check expression for all filter parameters.
func generateNilCheck(ft *FilterType) string {
	if ft.BaseType == "string" {
		return "eq == nil && ne == nil && contains == nil && startsWith == nil && endsWith == nil && like == nil && notLike == nil && in == nil && notIn == nil"
	}

	if ft.BaseType == "bool" {
		return "eq == nil && ne == nil"
	}

	return "eq == nil && ne == nil && lt == nil && lte == nil && gt == nil && gte == nil && in == nil && notIn == nil"
}

// toProtoTypeName converts base type to proto type name (e.g., "uint32" -> "UInt32").
func toProtoTypeName(baseType string) string {
	switch baseType {
	case "uint32":
		return "UInt32"
	case "uint64":
		return "UInt64"
	case "int32":
		return "Int32"
	case "int64":
		return "Int64"
	case "string":
		return "String"
	case "bool":
		return "Bool"
	default:
		return toPascalCase(baseType)
	}
}
