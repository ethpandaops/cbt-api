package main

import (
	"fmt"
	"sort"
	"strings"
)

// CodeGenerator generates the complete implementation code.
type CodeGenerator struct {
	spec      *OpenAPISpec
	protoInfo *ProtoInfo
}

// Generate produces the complete implementation.go file.
func (g *CodeGenerator) Generate() string {
	var sb strings.Builder

	// Package and imports
	sb.WriteString(g.generateHeader())
	sb.WriteString("\n\n")

	// Server struct
	sb.WriteString(g.generateServerStruct())
	sb.WriteString("\n\n")

	// Endpoint implementations
	sb.WriteString(generateEndpoints(g.spec, g.protoInfo))
	sb.WriteString("\n")

	// Type converters
	sb.WriteString(g.generateTypeConverters())
	sb.WriteString("\n")

	// Utility functions
	sb.WriteString(g.generateUtilities())
	sb.WriteString("\n")

	// Helper functions (parseUInt32List, etc.) - at end for vanity
	sb.WriteString(g.generateHelpers())
	sb.WriteString("\n\n")

	// Filter builders - at end for vanity
	sb.WriteString(generateFilterBuilders(g.protoInfo))

	return sb.String()
}

// generateHeader generates the package declaration and imports.
func (g *CodeGenerator) generateHeader() string {
	return `package server

// Code generated by generate-implementation. DO NOT EDIT.
// Source: openapi.yaml + proto files

import (
	"encoding/json"
	"net/http"
	"strconv"
	"strings"

	"github.com/ethpandaops/xatu-cbt-api/internal/config"
	"github.com/ethpandaops/xatu-cbt-api/internal/database"
	apierrors "github.com/ethpandaops/xatu-cbt-api/internal/errors"
	"github.com/ethpandaops/xatu-cbt-api/internal/handlers"
	clickhouse "github.com/ethpandaops/xatu-cbt-api/pkg/proto/clickhouse"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/wrapperspb"
)`
}

// generateServerStruct generates the Server struct definition.
func (g *CodeGenerator) generateServerStruct() string {
	return `// Server implements the generated ServerInterface.
type Server struct {
	db     database.DatabaseClient
	config *config.Config
}`
}

// generateHelpers generates helper functions for parsing lists.
func (g *CodeGenerator) generateHelpers() string {
	return `// Helper: Parse comma-separated uint32 list
func parseUInt32List(s string) []uint32 {
	parts := strings.Split(s, ",")
	result := make([]uint32, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if n, err := strconv.ParseUint(p, 10, 32); err == nil {
			result = append(result, uint32(n))
		}
	}
	return result
}

// Helper: Parse comma-separated uint64 list
func parseUInt64List(s string) []uint64 {
	parts := strings.Split(s, ",")
	result := make([]uint64, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if n, err := strconv.ParseUint(p, 10, 64); err == nil {
			result = append(result, n)
		}
	}
	return result
}

// Helper: Parse comma-separated int32 list
func parseInt32List(s string) []int32 {
	parts := strings.Split(s, ",")
	result := make([]int32, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if n, err := strconv.ParseInt(p, 10, 32); err == nil {
			result = append(result, int32(n))
		}
	}
	return result
}

// Helper: Parse comma-separated int64 list
func parseInt64List(s string) []int64 {
	parts := strings.Split(s, ",")
	result := make([]int64, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if n, err := strconv.ParseInt(p, 10, 64); err == nil {
			result = append(result, n)
		}
	}
	return result
}

// Helper: Parse comma-separated string list
func parseStringList(s string) []string {
	parts := strings.Split(s, ",")
	result := make([]string, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p != "" {
			result = append(result, p)
		}
	}
	return result
}`
}

// generateTypeConverters generates proto to OpenAPI type converter functions.
func (g *CodeGenerator) generateTypeConverters() string {
	var sb strings.Builder

	sb.WriteString("// Type converters: Proto → OpenAPI\n\n")

	// Collect unique tables and sort for deterministic output
	tableNames := make(map[string]bool)
	for _, endpoint := range g.spec.Endpoints {
		tableNames[endpoint.TableName] = true
	}

	sortedTables := make([]string, 0, len(tableNames))
	for name := range tableNames {
		sortedTables = append(sortedTables, name)
	}

	sort.Strings(sortedTables)

	// Generate a converter for each unique table
	for _, tableName := range sortedTables {
		itemType := getItemType(tableName)
		sb.WriteString(g.generateConverter(itemType))
	}

	return sb.String()
}

// generateConverter generates a proto→OpenAPI converter for a specific type.
func (g *CodeGenerator) generateConverter(itemType string) string {
	// Find the OpenAPI schema for this type
	schema, ok := g.spec.Types[itemType]
	if !ok {
		// No schema found, generate placeholder
		return fmt.Sprintf(`// protoToOpenAPI%s converts proto %s to OpenAPI type.
func protoToOpenAPI%s(p *clickhouse.%s) handlers.%s {
	return handlers.%s{}
}

`, itemType, itemType, itemType, itemType, itemType, itemType)
	}

	var sb strings.Builder

	sb.WriteString(fmt.Sprintf(`// protoToOpenAPI%s converts proto %s to OpenAPI type.
func protoToOpenAPI%s(p *clickhouse.%s) handlers.%s {
	result := handlers.%s{}

`, itemType, itemType, itemType, itemType, itemType, itemType))

	// Generate field mappings
	for _, field := range schema.Fields {
		fieldName := toPascalCase(field.Name)
		sb.WriteString(g.generateFieldMapping(fieldName, field.Type, field.Nullable))
	}

	sb.WriteString(`	return result
}

`)

	return sb.String()
}

// generateFieldMapping generates field mapping code for proto→OpenAPI conversion.
func (g *CodeGenerator) generateFieldMapping(fieldName string, fieldType string, nullable bool) string {
	if nullable {
		// Nullable fields use wrapperspb in proto
		// Proto: *wrapperspb.StringValue → OpenAPI: *string (oapi-codegen uses pointers)
		return fmt.Sprintf(`	if p.%s != nil {
		val := p.%s.GetValue()
		result.%s = &val
	}
`, fieldName, fieldName, fieldName)
	}

	// Check if field is a slice - slices are assigned directly (no &)
	// Proto: []string → OpenAPI: []string (after fixArrayPointers)
	if fieldType == "array" {
		return fmt.Sprintf(`	result.%s = p.%s
`, fieldName, fieldName)
	}

	// Check if field is a map - maps are assigned directly (no &)
	// Proto: map[string]string → OpenAPI: map[string]string (after fixMapPointers)
	// Maps are reference types in Go, taking their address creates double pointers
	if fieldType == "object" {
		return fmt.Sprintf(`	result.%s = p.%s
`, fieldName, fieldName)
	}

	// Non-nullable fields need address taken
	// Proto: uint32 → OpenAPI: *uint32 (oapi-codegen generates all fields as pointers with omitempty)
	return fmt.Sprintf(`	result.%s = &p.%s
`, fieldName, fieldName)
}

// generateUtilities generates utility functions for HTTP handling.
func (g *CodeGenerator) generateUtilities() string {
	return `// Utility functions

func writeJSON(w http.ResponseWriter, data any) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(data); err != nil {
		// Log error but don't expose to client
		return
	}
}

func writeError(w http.ResponseWriter, status int, err error) {
	// Map HTTP status to appropriate Status error
	var apiErr *apierrors.Status
	switch status {
	case http.StatusBadRequest:
		apiErr = apierrors.BadRequest(err.Error())
	case http.StatusNotFound:
		apiErr = apierrors.NotFound(err.Error())
	case http.StatusInternalServerError:
		apiErr = apierrors.Internal(err.Error())
	default:
		apiErr = apierrors.Internal(err.Error())
	}

	apiErr.WriteJSON(w)
}

func generateNextPageToken(currentToken string, itemCount int) string {
	// Simple offset-based pagination
	offset := 0
	if currentToken != "" {
		offset, _ = strconv.Atoi(currentToken)
	}
	return strconv.Itoa(offset + itemCount)
}

// buildQueryOptions creates query options with conditional WithFinal.
func (s *Server) buildQueryOptions() []clickhouse.QueryOption {
	opts := []clickhouse.QueryOption{
		clickhouse.WithDatabase(s.config.ClickHouse.Database),
	}
	if s.config.ClickHouse.UseFinal {
		opts = append(opts, clickhouse.WithFinal())
	}

	return opts
}
`
}
