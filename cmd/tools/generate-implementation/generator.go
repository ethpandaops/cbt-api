package main

import (
	"fmt"
	"sort"
	"strings"
)

// CodeGenerator generates the complete implementation code.
type CodeGenerator struct {
	spec      *OpenAPISpec
	protoInfo *ProtoInfo
}

// Generate produces the complete implementation.go file.
func (g *CodeGenerator) Generate() string {
	var sb strings.Builder

	// Package and imports
	sb.WriteString(g.generateHeader())
	sb.WriteString("\n\n")

	// Server struct
	sb.WriteString(g.generateServerStruct())
	sb.WriteString("\n\n")

	// Endpoint implementations
	sb.WriteString(generateEndpoints(g.spec, g.protoInfo))
	sb.WriteString("\n")

	// Type converters (placeholder - basic pass-through for now)
	sb.WriteString(g.generateTypeConverters())
	sb.WriteString("\n")

	// Utility functions
	sb.WriteString(g.generateUtilities())
	sb.WriteString("\n")

	// Helper functions (parseUInt32List, etc.) - at end for vanity
	sb.WriteString(g.generateHelpers())
	sb.WriteString("\n\n")

	// Filter builders - at end for vanity
	sb.WriteString(generateFilterBuilders(g.protoInfo))

	return sb.String()
}

func (g *CodeGenerator) generateHeader() string {
	return `package server

// Code generated by generate-implementation. DO NOT EDIT.
// Source: openapi.yaml + proto files

import (
	"context"
	"encoding/json"
	"net/http"
	"strconv"
	"strings"

	clickhouse "github.com/ethpandaops/xatu-cbt/pkg/proto/clickhouse"
	"github.com/ethpandaops/xatu-cbt-api/internal/config"
	"github.com/ethpandaops/xatu-cbt-api/internal/database"
	"github.com/ethpandaops/xatu-cbt-api/internal/handlers"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/wrapperspb"
)`
}

func (g *CodeGenerator) generateServerStruct() string {
	return `// Server implements the generated ServerInterface.
type Server struct {
	db     *database.Client
	config *config.Config
}`
}

func (g *CodeGenerator) generateHelpers() string {
	return `// Helper: Parse comma-separated uint32 list
func parseUInt32List(s string) []uint32 {
	parts := strings.Split(s, ",")
	result := make([]uint32, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if n, err := strconv.ParseUint(p, 10, 32); err == nil {
			result = append(result, uint32(n))
		}
	}
	return result
}

// Helper: Parse comma-separated uint64 list
func parseUInt64List(s string) []uint64 {
	parts := strings.Split(s, ",")
	result := make([]uint64, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if n, err := strconv.ParseUint(p, 10, 64); err == nil {
			result = append(result, n)
		}
	}
	return result
}

// Helper: Parse comma-separated int32 list
func parseInt32List(s string) []int32 {
	parts := strings.Split(s, ",")
	result := make([]int32, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if n, err := strconv.ParseInt(p, 10, 32); err == nil {
			result = append(result, int32(n))
		}
	}
	return result
}

// Helper: Parse comma-separated int64 list
func parseInt64List(s string) []int64 {
	parts := strings.Split(s, ",")
	result := make([]int64, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if n, err := strconv.ParseInt(p, 10, 64); err == nil {
			result = append(result, n)
		}
	}
	return result
}

// Helper: Parse comma-separated string list
func parseStringList(s string) []string {
	parts := strings.Split(s, ",")
	result := make([]string, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p != "" {
			result = append(result, p)
		}
	}
	return result
}`
}

func (g *CodeGenerator) generateTypeConverters() string {
	var sb strings.Builder

	sb.WriteString("// Type converters: Proto â†’ OpenAPI\n\n")

	// Collect unique tables and sort for deterministic output
	tableNames := make(map[string]bool)
	for _, endpoint := range g.spec.Endpoints {
		tableNames[endpoint.TableName] = true
	}

	sortedTables := make([]string, 0, len(tableNames))
	for name := range tableNames {
		sortedTables = append(sortedTables, name)
	}

	sort.Strings(sortedTables)

	// Generate a converter for each unique table
	for _, tableName := range sortedTables {
		itemType := getItemType(tableName)

		// For now, generate a simple pass-through converter
		// In a real implementation, this would map fields properly
		sb.WriteString(fmt.Sprintf(`// protoToOpenAPI%s converts proto %s to OpenAPI type.
func protoToOpenAPI%s(p *clickhouse.%s) handlers.%s {
	// TODO: Implement proper field mapping
	// For now, this is a placeholder that needs manual field mapping
	return handlers.%s{}
}

`, itemType, itemType, itemType, itemType, itemType, itemType))
	}

	return sb.String()
}

func (g *CodeGenerator) generateUtilities() string {
	return `// Utility functions

func writeJSON(w http.ResponseWriter, data any) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(data); err != nil {
		// Log error but don't expose to client
		return
	}
}

func writeError(w http.ResponseWriter, status int, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(map[string]string{
		"error": err.Error(),
	})
}

func generateNextPageToken(currentToken string, itemCount int) string {
	// Simple offset-based pagination
	offset := 0
	if currentToken != "" {
		offset, _ = strconv.Atoi(currentToken)
	}
	return strconv.Itoa(offset + itemCount)
}
`
}
