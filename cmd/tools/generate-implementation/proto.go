package main

import (
	"fmt"
	"os"
	"strings"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

// ProtoInfo contains information extracted from proto files.
type ProtoInfo struct {
	FilterTypes   map[string]*FilterType       // "UInt32Filter" → FilterType
	QueryBuilders map[string]string            // "fct_block" → "BuildListFctBlockQuery"
	RequestTypes  map[string]string            // "fct_block" → "ListFctBlockRequest"
	ResponseTypes map[string]string            // "fct_block" → "ListFctBlockResponse"
	RequestFields map[string]map[string]string // "fct_block" → {"slot" → "UInt32Filter", "block_root" → "NullableStringFilter"}
}

// FilterType represents a filter type definition.
type FilterType struct {
	Name       string   // "UInt32Filter"
	BaseType   string   // "uint32"
	IsNullable bool     // false
	IsMap      bool     // false
	Operators  []string // ["eq", "ne", "lt", "lte", "gt", "gte", "in", "not_in"]
}

// analyzeProtos analyzes proto files and extracts filter types, query builders, and request field mappings.
func analyzeProtos(protoPath string) (*ProtoInfo, error) {
	info := &ProtoInfo{
		FilterTypes:   make(map[string]*FilterType),
		QueryBuilders: make(map[string]string),
		RequestTypes:  make(map[string]string),
		ResponseTypes: make(map[string]string),
		RequestFields: make(map[string]map[string]string),
	}

	// Define known filter types (from clickhouse-proto-gen)
	info.FilterTypes = getKnownFilterTypes()

	// Use protoc descriptor file (robust, always generated by Makefile)
	descriptorPath := ".descriptors.pb"
	if err := parseProtoDescriptors(descriptorPath, info); err != nil {
		return nil, fmt.Errorf("parsing proto descriptors: %w (ensure 'make generate-descriptors' has been run)", err)
	}

	return info, nil
}

// parseProtoDescriptors parses a protobuf descriptor file to extract service and message information.
// This is more robust than convention-based parsing.
func parseProtoDescriptors(descriptorPath string, info *ProtoInfo) error {
	// Read descriptor file
	data, err := os.ReadFile(descriptorPath)
	if err != nil {
		return fmt.Errorf("reading descriptor file: %w", err)
	}

	// Parse FileDescriptorSet
	fds := &descriptorpb.FileDescriptorSet{}
	if err := proto.Unmarshal(data, fds); err != nil {
		return fmt.Errorf("unmarshaling descriptor: %w", err)
	}

	// First pass: collect all message types for field type lookup
	messageTypes := make(map[string]*descriptorpb.DescriptorProto)

	for _, file := range fds.GetFile() {
		pkg := file.GetPackage()
		for _, msgType := range file.GetMessageType() {
			fullName := "." + pkg + "." + msgType.GetName()
			messageTypes[fullName] = msgType
		}
	}

	// Second pass: extract service information and request fields
	for _, file := range fds.GetFile() {
		// Parse services to get query builders and request/response types
		for _, service := range file.GetService() {
			for _, method := range service.GetMethod() {
				methodName := method.GetName()

				// Process both List and Get methods
				if !strings.HasPrefix(methodName, "List") && !strings.HasPrefix(methodName, "Get") {
					continue
				}

				inputType := method.GetInputType()   // e.g., ".cbt.ListFctBlockRequest" or ".cbt.GetFctBlockRequest"
				outputType := method.GetOutputType() // e.g., ".cbt.ListFctBlockResponse" or ".cbt.GetFctBlockResponse"

				// Extract table name from request type
				// ".cbt.ListFctBlockRequest" → "fct_block"
				// ".cbt.GetFctBlockRequest" → "fct_block"
				tableName := extractTableNameFromType(inputType)
				if tableName == "" {
					continue
				}

				// Determine operation type (List or Get)
				// Proto RPC methods are named just "List" or "Get", not "ListTableName" or "GetTableName"
				var operationType string
				if methodName == "List" {
					operationType = "List"
				} else if methodName == "Get" {
					operationType = "Get"
				} else if strings.HasPrefix(methodName, "List") {
					operationType = "List"
				} else if strings.HasPrefix(methodName, "Get") {
					operationType = "Get"
				}

				// Use composite key: "tableName:Operation" to distinguish List from Get
				// e.g., "fct_block:List" and "fct_block:Get"
				key := tableName + ":" + operationType

				// Build query builder name from table name
				// Proto methods are just "List" or "Get", so we need to construct full name
				// "fct_block" + "List" → "BuildListFctBlockQuery"
				// "fct_block" + "Get" → "BuildGetFctBlockQuery"
				pascalTable := toPascalCase(tableName)
				queryBuilderName := "Build" + operationType + pascalTable + "Query"

				info.QueryBuilders[key] = queryBuilderName
				info.RequestTypes[key] = cleanTypeName(inputType)
				info.ResponseTypes[key] = cleanTypeName(outputType)
			}
		}

		// Parse message types for request field information
		// Only process List requests, as Get requests don't have filter fields
		for _, msgType := range file.GetMessageType() {
			msgName := msgType.GetName()
			if !strings.HasPrefix(msgName, "List") || !strings.HasSuffix(msgName, "Request") {
				continue
			}

			// Extract table name from message name
			// "ListFctBlockRequest" → "fct_block"
			tableName := extractTableNameFromMessage(msgName)
			if tableName == "" {
				continue
			}

			fields := make(map[string]string)

			for _, field := range msgType.GetField() {
				fieldName := toSnakeCase(field.GetName())
				fieldType := getFieldTypeFromDescriptor(field, messageTypes)

				if fieldType != "" {
					fields[fieldName] = fieldType
				}
			}

			info.RequestFields[tableName] = fields
		}
	}

	return nil
}

// extractTableNameFromType extracts table name from a proto type name.
// Example: ".cbt.ListFctBlockRequest" → "fct_block".
func extractTableNameFromType(typeName string) string {
	// Remove package prefix: ".cbt.ListFctBlockRequest" → "ListFctBlockRequest"
	parts := strings.Split(typeName, ".")
	msgName := parts[len(parts)-1]

	return extractTableNameFromMessage(msgName)
}

// extractTableNameFromMessage extracts table name from a message name.
// Example: "ListFctBlockRequest" → "fct_block".
func extractTableNameFromMessage(msgName string) string {
	// Remove "List" prefix and "Request"/"Response" suffix
	msgName = strings.TrimPrefix(msgName, "List")
	msgName = strings.TrimPrefix(msgName, "Get")
	msgName = strings.TrimSuffix(msgName, "Request")
	msgName = strings.TrimSuffix(msgName, "Response")

	// Convert from PascalCase to snake_case
	return toSnakeCase(msgName)
}

// cleanTypeName removes package prefix from type name.
// Example: ".cbt.ListFctBlockRequest" → "ListFctBlockRequest".
func cleanTypeName(typeName string) string {
	parts := strings.Split(typeName, ".")
	name := parts[len(parts)-1]

	// Apply protoc's capitalization rules: numbers followed by letters get capitalized
	// "ListFctAttestationFirstSeenChunked50msRequest" -> "ListFctAttestationFirstSeenChunked50MsRequest"
	// "ListFctNodeActiveLast24hRequest" -> "ListFctNodeActiveLast24HRequest"
	return normalizeProtoTypeName(name)
}

// normalizeProtoTypeName applies the same capitalization rules that protoc uses for Go code generation.
// Specifically, it capitalizes letters that immediately follow digits in identifiers.
func normalizeProtoTypeName(name string) string {
	runes := []rune(name)
	for i := 1; i < len(runes); i++ {
		// If previous char is a digit and current char is a lowercase letter, capitalize it
		if runes[i-1] >= '0' && runes[i-1] <= '9' && runes[i] >= 'a' && runes[i] <= 'z' {
			runes[i] = runes[i] - 32 // Convert to uppercase
		}
	}

	return string(runes)
}

// getFieldTypeFromDescriptor gets the field type name from a field descriptor.
func getFieldTypeFromDescriptor(field *descriptorpb.FieldDescriptorProto, messageTypes map[string]*descriptorpb.DescriptorProto) string {
	// Check if it's a message type (filter types)
	if field.GetTypeName() != "" {
		// ".cbt.NullableStringFilter" → "NullableStringFilter"
		parts := strings.Split(field.GetTypeName(), ".")

		return parts[len(parts)-1]
	}

	// Scalar types - not used for filters
	return ""
}

// getKnownFilterTypes returns the known filter types from clickhouse-proto-gen.
func getKnownFilterTypes() map[string]*FilterType {
	return map[string]*FilterType{
		// Scalar filters
		"UInt32Filter": {
			Name:       "UInt32Filter",
			BaseType:   "uint32",
			IsNullable: false,
			IsMap:      false,
			Operators:  []string{"eq", "ne", "lt", "lte", "gt", "gte", "in", "not_in"},
		},
		"UInt64Filter": {
			Name:       "UInt64Filter",
			BaseType:   "uint64",
			IsNullable: false,
			IsMap:      false,
			Operators:  []string{"eq", "ne", "lt", "lte", "gt", "gte", "in", "not_in"},
		},
		"Int32Filter": {
			Name:       "Int32Filter",
			BaseType:   "int32",
			IsNullable: false,
			IsMap:      false,
			Operators:  []string{"eq", "ne", "lt", "lte", "gt", "gte", "in", "not_in"},
		},
		"Int64Filter": {
			Name:       "Int64Filter",
			BaseType:   "int64",
			IsNullable: false,
			IsMap:      false,
			Operators:  []string{"eq", "ne", "lt", "lte", "gt", "gte", "in", "not_in"},
		},
		"StringFilter": {
			Name:       "StringFilter",
			BaseType:   "string",
			IsNullable: false,
			IsMap:      false,
			Operators: []string{
				"eq", "ne", "contains", "starts_with", "ends_with",
				"like", "not_like", "in", "not_in",
			},
		},
		"BoolFilter": {
			Name:       "BoolFilter",
			BaseType:   "bool",
			IsNullable: false,
			IsMap:      false,
			Operators:  []string{"eq", "ne"},
		},

		// Nullable filters
		"NullableUInt32Filter": {
			Name:       "NullableUInt32Filter",
			BaseType:   "uint32",
			IsNullable: true,
			IsMap:      false,
			Operators: []string{
				"eq", "ne", "lt", "lte", "gt", "gte", "in", "not_in",
				"is_null", "is_not_null",
			},
		},
		"NullableUInt64Filter": {
			Name:       "NullableUInt64Filter",
			BaseType:   "uint64",
			IsNullable: true,
			IsMap:      false,
			Operators: []string{
				"eq", "ne", "lt", "lte", "gt", "gte", "in", "not_in",
				"is_null", "is_not_null",
			},
		},
		"NullableInt32Filter": {
			Name:       "NullableInt32Filter",
			BaseType:   "int32",
			IsNullable: true,
			IsMap:      false,
			Operators: []string{
				"eq", "ne", "lt", "lte", "gt", "gte", "in", "not_in",
				"is_null", "is_not_null",
			},
		},
		"NullableInt64Filter": {
			Name:       "NullableInt64Filter",
			BaseType:   "int64",
			IsNullable: true,
			IsMap:      false,
			Operators: []string{
				"eq", "ne", "lt", "lte", "gt", "gte", "in", "not_in",
				"is_null", "is_not_null",
			},
		},
		"NullableStringFilter": {
			Name:       "NullableStringFilter",
			BaseType:   "string",
			IsNullable: true,
			IsMap:      false,
			Operators: []string{
				"eq", "ne", "contains", "starts_with", "ends_with",
				"like", "not_like", "in", "not_in",
				"is_null", "is_not_null",
			},
		},
		"NullableBoolFilter": {
			Name:       "NullableBoolFilter",
			BaseType:   "bool",
			IsNullable: true,
			IsMap:      false,
			Operators:  []string{"eq", "ne", "is_null", "is_not_null"},
		},

		// Map filters
		"MapStringStringFilter": {
			Name:       "MapStringStringFilter",
			BaseType:   "map[string]string",
			IsNullable: false,
			IsMap:      true,
			Operators:  []string{"has_key", "not_has_key", "has_any_key", "has_all_keys"},
		},
		"MapStringUInt32Filter": {
			Name:       "MapStringUInt32Filter",
			BaseType:   "map[string]uint32",
			IsNullable: false,
			IsMap:      true,
			Operators:  []string{"has_key", "not_has_key", "has_any_key", "has_all_keys"},
		},
		"MapStringInt32Filter": {
			Name:       "MapStringInt32Filter",
			BaseType:   "map[string]int32",
			IsNullable: false,
			IsMap:      true,
			Operators:  []string{"has_key", "not_has_key", "has_any_key", "has_all_keys"},
		},
		"MapStringUInt64Filter": {
			Name:       "MapStringUInt64Filter",
			BaseType:   "map[string]uint64",
			IsNullable: false,
			IsMap:      true,
			Operators:  []string{"has_key", "not_has_key", "has_any_key", "has_all_keys"},
		},
		"MapStringInt64Filter": {
			Name:       "MapStringInt64Filter",
			BaseType:   "map[string]int64",
			IsNullable: false,
			IsMap:      true,
			Operators:  []string{"has_key", "not_has_key", "has_any_key", "has_all_keys"},
		},
	}
}

// toSnakeCase converts PascalCase to snake_case.
// Handles numeric sequences: "Top100By" → "top_100_by".
func toSnakeCase(s string) string {
	var result strings.Builder

	for i, r := range s {
		// Add underscore before uppercase letters
		if i > 0 && r >= 'A' && r <= 'Z' {
			// Check if previous char is lowercase or next char is lowercase
			prevIsLower := i > 0 && s[i-1] >= 'a' && s[i-1] <= 'z'
			nextIsLower := i < len(s)-1 && s[i+1] >= 'a' && s[i+1] <= 'z'

			if prevIsLower || nextIsLower {
				result.WriteRune('_')
			}
		}

		// Add underscore before digit if previous char was a lowercase letter
		if i > 0 && r >= '0' && r <= '9' && s[i-1] >= 'a' && s[i-1] <= 'z' {
			result.WriteRune('_')
		}

		result.WriteRune(r)
	}

	return strings.ToLower(result.String())
}

// toPascalCase converts snake_case to PascalCase.
// Handles numeric prefixes: "50ms" → "50Ms".
func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		if len(parts[i]) > 0 {
			// Handle parts that start with digits (e.g., "50ms" -> "50Ms")
			if parts[i][0] >= '0' && parts[i][0] <= '9' {
				// Find first letter after digits
				for j := 0; j < len(parts[i]); j++ {
					if parts[i][j] >= 'a' && parts[i][j] <= 'z' {
						// Capitalize first letter found
						parts[i] = parts[i][:j] + strings.ToUpper(parts[i][j:j+1]) + parts[i][j+1:]

						break
					}
				}
			} else {
				// Normal case: capitalize first letter
				parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
			}
		}
	}

	return strings.Join(parts, "")
}
